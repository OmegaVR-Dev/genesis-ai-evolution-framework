<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Vaporwave Archive Visualizer - Enhanced Unity Approach | Developed with GitHub Copilot AI Assistant</title>
</head>
<body style="margin:0; overflow:hidden; background:#000;">
  <!-- RETRO TIME CAPSULE AUDIO PLAYER - Connected to Main Channel Playlist -->
  <audio id="player" controls loop preload="auto" 
         style="position:absolute; z-index:10; top:10px; left:10px; opacity:0.85; width:320px;"
         data-playlist="retro-time-capsule-therapeutic">
    <!-- Fallback for browsers that don't support the audio element -->
    <p>Your browser doesn't support HTML5 audio. Please upgrade to experience the therapeutic soundscapes.</p>
  </audio>
  
  <!-- PLAYLIST SELECTOR FOR THERAPEUTIC MODES -->
  <div id="audioControls" style="position:absolute; z-index:10; top:80px; left:10px; font-family:monospace; font-size:12px; color:#ff00ff; text-shadow:0 0 5px #ff00ff;">
    <button onclick="loadTherapeuticPlaylist()" style="background:rgba(255,0,255,0.2); border:1px solid #ff00ff; color:#ff00ff; padding:5px; border-radius:3px; cursor:pointer;">
      üéµ Load Therapeutic Playlist
    </button>
    <button onclick="loadNostalgiaPlaylist()" style="background:rgba(0,255,255,0.2); border:1px solid #00ffff; color:#00ffff; padding:5px; border-radius:3px; cursor:pointer; margin-left:5px;">
      üí´ Load Nostalgia Mix
    </button>
  </div>
  
  <!-- STATUS DISPLAY FOR FRAME SEQUENCES -->
  <div id="statusDisplay" style="position:absolute; z-index:10; top:10px; right:10px; color:#ff00ff; font-family:monospace; font-size:14px; text-shadow:0 0 10px #ff00ff; opacity:0.9; background:rgba(0,0,0,0.7); padding:10px; border-radius:5px; display:none;">
    <div id="frameInfo">üé¨ Frame Mode</div>
    <div id="progressBar" style="width:200px; height:4px; background:#333; margin:5px 0; border-radius:2px;">
      <div id="progressFill" style="height:100%; background:linear-gradient(90deg, #ff00ff, #00ffff); border-radius:2px; width:0%;"></div>
    </div>
    <div id="controls" style="font-size:12px; opacity:0.8;">
      SPACE: Next | V: Video | Y: AI-Demo | G: Grok4-Archive | M: Mall-Nostalgia | T: Deflicker | I: Image | F: Info | C: Video% | Q: Quality | H: Timeline | R: Therapeutic
    </div>
  </div>
  
  <canvas id="canvas" style="width:100vw; height:100vh; display:block;"></canvas>
  
  <script>
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
if (!gl) throw new Error('WebGL not supported');

const isWebGL2 = gl instanceof WebGL2RenderingContext;
console.log('üå¥ Vaporwave Archive Visualizer using:', isWebGL2 ? 'WebGL 2.0' : 'WebGL 1.0');
console.log('ü§ù Developed in collaboration with GitHub Copilot AI Assistant');
console.log('üíô Therapeutic mission: Healing through technology & nostalgia');
console.log('üéØ 17+ years restoration expertise meets AI-enhanced development');
console.log('‚è∞ Enhanced therapeutic timing: 3-second transitions for content absorption');

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ENHANCED ARCHIVE.ORG LOCAL FILE SYSTEM (No more CORS/400 errors!)
console.log('üè† LOCAL FILE MODE: Using downloaded Archive.org collections');
console.log('üö´ Bypassing remote Archive.org requests to avoid CORS/400 errors');
console.log('üìÅ Expected folder structure:');
console.log('  ./videos/collection_90s_commercials/[your_ogg_files]');
console.log('  ./videos/vintage_commercials_80s_90s/[your_ogg_files]');
console.log('  ./videos/kmart_pharmacy_70s_80s/[your_ogg_files]');
console.log('  ./images/collection_90s_commercials/[extracted_screenshots]');
console.log('  ./audio/therapeutic/[healing_audio_files]');
console.log('  ./audio/nostalgia/[nostalgic_audio_files]');
console.log('‚ö° Benefits: Faster loading, no network dependency, full control');

// OLD ARCHIVE.ORG API (Commented out due to CORS/400 issues)
/*
async function fetchArchivePlaylist(playlistId, filters = {}) {
  const baseQuery = `collection:${playlistId} AND (mediatype:image OR mediatype:audio OR mediatype:movies)`;
  
  // Add your custom filters
  let query = baseQuery;
  if (filters.yearRange) query += ` AND year:[${filters.yearRange.start} TO ${filters.yearRange.end}]`;
  if (filters.subject) query += ` AND subject:(${filters.subject})`;
  if (filters.format) query += ` AND format:(${filters.format})`;
  
  // Prioritize OGG audio for web compatibility
  if (filters.audioFormats) {
    query += ` AND (format:ogg OR format:mp3 OR format:wav)`;
  }
  
  const apiUrl = `https://archive.org/advancedsearch.php?q=${encodeURIComponent(query)}&fl[]=identifier&fl[]=title&fl[]=year&fl[]=subject&fl[]=format&sort[]=&rows=200&page=1&output=json`;

  try {
    const response = await fetch(apiUrl);
    if (!response.ok) throw new Error(`API error: ${response.status}`);
    const data = await response.json();
    const items = data.response.docs || [];

    console.log(`üìö Found ${items.length} items from Archive.org`);

    // Enhanced metadata mapping with audio support
    const content = items.map(item => {
      const isAudio = item.format && (item.format.includes('Ogg Vorbis') || item.format.includes('VBR MP3') || item.format.includes('wav'));
      const isVideo = item.format && (item.format.includes('h.264') || item.format.includes('MPEG4') || item.format.includes('AVI'));
      
      return {
        url: isAudio 
          ? `https://archive.org/download/${item.identifier}/${item.identifier}.ogg` // Prioritize OGG!
          : `https://archive.org/services/img/${item.identifier}`,
        detailUrl: `https://archive.org/details/${item.identifier}`,
        title: item.title || 'Untitled',
        year: item.year || 'Unknown',
        subject: item.subject || [],
        identifier: item.identifier,
        format: item.format || 'Unknown',
        mediaType: isAudio ? 'audio' : isVideo ? 'video' : 'image',
        // Add vaporwave scoring based on metadata
        vaporScore: calculateVaporScore(item),
        // OGG quality bonus for web performance
        webOptimized: isAudio && item.format && item.format.includes('Ogg Vorbis')
      };
    });

    return content.filter(item => item.url && item.vaporScore > 0);
  } catch (error) {
    console.warn('Archive.org API unavailable (CORS/Network issue):', error.message);
    console.log('üí° Using fallback: Add local content or run from web server to access Archive.org');
    return [];
  }
}
*/
// END OF COMMENTED ARCHIVE.ORG API

// VAPORWAVE AESTHETIC SCORING SYSTEM
function calculateVaporScore(item) {
  let score = 50; // Base score
  const title = (item.title || '').toLowerCase();
  const subjects = (item.subject || []).join(' ').toLowerCase();
  const year = parseInt(item.year) || 0;
  
  // Year-based scoring (80s-90s premium)
  if (year >= 1980 && year <= 1995) score += 30;
  else if (year >= 1970 && year <= 1979) score += 20;
  else if (year >= 1996 && year <= 2000) score += 10;
  
  // Keyword scoring
  const vaporKeywords = ['retro', 'neon', 'synthwave', 'cyber', 'digital', 'computer', 'tech', 'aesthetic', 'vaporwave', 'outrun'];
  vaporKeywords.forEach(keyword => {
    if (title.includes(keyword) || subjects.includes(keyword)) score += 15;
  });
  
  // Negative scoring for obviously non-vapor content
  const negativeKeywords = ['text', 'document', 'book', 'manual'];
  negativeKeywords.forEach(keyword => {
    if (title.includes(keyword) || subjects.includes(keyword)) score -= 20;
  });
  
  return Math.max(0, score);
}

// ENHANCED INDEXEDDB CACHE WITH METADATA
const DB_NAME = 'VaporwaveCache_v2';
const STORE_NAME = 'images';

async function openCache() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 2);
    request.onupgradeneeded = event => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'identifier' });
        store.createIndex('vaporScore', 'vaporScore', { unique: false });
        store.createIndex('year', 'year', { unique: false });
      }
    };
    request.onsuccess = event => resolve(event.target.result);
    request.onerror = event => reject(event.target.error);
  });
}

async function cacheImages(images) {
  const db = await openCache();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    images.forEach(img => store.put({...img, cachedAt: Date.now()}));
    tx.oncomplete = () => {
      console.log('üíæ Cached', images.length, 'archive images');
      resolve();
    };
    tx.onerror = reject;
  });
}

async function getCachedImages(minVaporScore = 60) {
  const db = await openCache();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const index = store.index('vaporScore');
    const range = IDBKeyRange.lowerBound(minVaporScore);
    const request = index.getAll(range);
    request.onsuccess = () => {
      const results = request.result.sort((a, b) => b.vaporScore - a.vaporScore);
      console.log('üíø Retrieved', results.length, 'high-vapor images from cache');
      resolve(results);
    };
    request.onerror = reject;
  });
}

// WEBGL TEXTURE CREATION FROM ARCHIVE IMAGES
async function createTextureFromURL(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = () => {
      // Create texture
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      
      // Upload image data
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      
      // Unity-style filtering for smooth scaling
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      
      console.log('üñºÔ∏è Created WebGL texture from archive image');
      resolve(texture);
    };
    
    img.onerror = () => {
      console.warn('Failed to load image:', url);
      reject(new Error('Image load failed'));
    };
    
    img.src = url;
  });
}

// ENHANCED VAPORWAVE VIDEO ATLAS WITH DIRECT OGG VIDEO SUPPORT + FRAME SEQUENCES
class VaporwaveVideoAtlas {
  constructor() {
    this.images = [];
    this.videos = []; // NEW: Direct OGG video support!
    this.currentTexture = null;
    this.nextTexture = null;
    this.currentVideo = null; // NEW: Current playing video element
    this.fadeProgress = 0;
    this.lastBeatTime = 0;
    this.beatThreshold = 0.3;
    this.preloadQueue = [];
    this.maxPreload = 3;
    
    // Vaporwave aesthetic parameters - ENHANCED FOR THERAPEUTIC EXPERIENCE
    this.dreamSpeed = 0.001; // Slower transitions for therapeutic viewing (was 0.005)
    this.beatFadeMultiplier = 3.0;
    this.glitchIntensity = 0.0;
    
    // VIDEO PLAYBACK SYSTEM (Enhanced for your OGG collection!)
    this.videoFolder = './videos/'; // Your destination folder
    this.availableVideos = []; // List of your 200+ OGG videos
    this.videoSequenceChance = 0.7; // 70% chance for videos (you have 200!)
    this.videoPlaybackMode = 'texture'; // 'texture' or 'overlay'
    
    // Frame sequence fallback (still supported)
    this.frameSequences = {};
    this.currentFrames = null;
    this.frameIndex = 0;
    this.baseFrameRate = 24;
    this.currentFrameRate = 24;
    this.lastFrameTime = 0;
    this.frameSpeedMultiplier = 1.0;
    this.availableSequences = [];
  }

  async init(playlistId = 'local_files', filters = {}) {
    console.log('üìÅ LOCAL FILE MODE: Using your downloaded Archive.org collection');
    console.log('ÔøΩ Bypassing Archive.org remote requests (CORS/400 errors avoided)');
    
    // STEP 1: Detect your downloaded OGG videos
    await this.detectOggVideos();
    
    // STEP 2: Load local images (no more Archive.org fetching)
    await this.loadLocalImages();
    
    console.log(`üå¥ Initialized with ${this.images.length} local images`);
    console.log(`üé¨ Detected ${this.availableVideos.length} OGG videos for direct playback!`);
    
    // Initialize frame sequences from local folders
    this.detectVideoSequences();
    
    // Preload initial textures from local files
    await this.preloadTextures();
    
    // Prioritize video content since you have them downloaded
    if (this.availableVideos.length > 0) {
      this.videoSequenceChance = 0.9; // 90% videos since you have local files
      console.log('üéØ Local file mode: 90% OGG videos, 10% images/frames');
    }
    
    return this.images.length > 0 || this.availableVideos.length > 0;
  }

  // FRAME SEQUENCE METHODS (Your brilliant addition!)
  
  // NEW: Load local images from your downloaded collection
  async loadLocalImages() {
    console.log('üñºÔ∏è Loading local images from your downloaded Archive.org collection...');
    
    // Define your local image collection structure
    const localImageCollections = [
      // Collection 1: 90s Commercials screenshots/thumbnails
      {
        folder: './images/collection_90s_commercials/',
        category: '90s_commercials',
        files: [
          // Add your actual image files here, e.g.:
          // 'nickelodeon_ad_01.jpg', 'toy_commercial_01.jpg', 'cereal_spot_01.jpg',
          // 'happy_meal_ad.jpg', 'saturday_morning_01.jpg'
        ]
      },
      
      // Collection 2: Vintage 80s/90s ads
      {
        folder: './images/vintage_commercials_80s_90s/',
        category: 'vintage_80s_90s',
        files: [
          // Add your actual files, e.g.:
          // 'cbs_breakfast_ad.jpg', 'abc_cartoon_break.jpg', 'fox_promo.jpg'
        ]
      },
      
      // Collection 3: K-mart/Mall nostalgia
      {
        folder: './images/kmart_pharmacy_70s_80s/',
        category: 'mall_nostalgia',
        files: [
          // Add your files, e.g.:
          // 'kmart_store_01.jpg', 'pharmacy_spot_01.jpg', 'mall_interior.jpg'
        ]
      },
      
      // Collection 4: General screenshots from any other downloaded content
      {
        folder: './images/general/',
        category: 'general_nostalgic',
        files: [
          // Add any other screenshots/images you've extracted
          // 'retro_tech.jpg', 'vhs_aesthetic.jpg', 'neon_graphics.jpg'
        ]
      }
    ];
    
    const localImages = [];
    
    // Process each collection
    for (const collection of localImageCollections) {
      for (const filename of collection.files) {
        const imageInfo = {
          url: collection.folder + filename,
          detailUrl: null, // No remote detail URL needed
          title: this.generateTitleFromFilename(filename),
          category: collection.category,
          identifier: filename.replace(/\.[^/.]+$/, ""), // Remove extension
          format: filename.split('.').pop().toUpperCase(),
          mediaType: 'image',
          vaporScore: this.calculateLocalVaporScore(filename, collection.category),
          isLocal: true,
          localPath: collection.folder + filename
        };
        
        localImages.push(imageInfo);
        console.log(`üì∏ Registered local image: ${filename} (Score: ${imageInfo.vaporScore})`);
      }
    }
    
    this.images = localImages;
    
    if (localImages.length === 0) {
      console.log('üí° No local images configured. To add your extracted images:');
      console.log('üìÅ 1. Create folders: ./images/collection_90s_commercials/, ./images/vintage_commercials_80s_90s/, etc.');
      console.log('üì∏ 2. Extract screenshots from your OGG videos or save thumbnails');
      console.log('üìù 3. Edit the localImageCollections array above with your actual filenames');
      console.log('üéØ 4. This completely eliminates Archive.org dependency!');
      
      // Create a demo entry so the system works
      localImages.push({
        url: './images/demo_nostalgic.jpg',
        title: 'Demo Nostalgic Image',
        category: 'demo',
        identifier: 'demo_nostalgic',
        format: 'JPG',
        mediaType: 'image',
        vaporScore: 75,
        isLocal: true,
        localPath: './images/demo_nostalgic.jpg'
      });
      
      this.images = localImages;
    }
    
    return localImages;
  }
  
  // Generate human-readable titles from filenames
  generateTitleFromFilename(filename) {
    return filename
      .replace(/\.[^/.]+$/, "") // Remove extension
      .replace(/_/g, ' ') // Replace underscores with spaces
      .replace(/\b\w/g, l => l.toUpperCase()); // Capitalize first letters
  }
  
  // Calculate vaporwave score for local files based on filename and category
  calculateLocalVaporScore(filename, category) {
    let score = 60; // Base score
    const name = filename.toLowerCase();
    
    // Category bonuses
    if (category === '90s_commercials') score += 25;
    if (category === 'vintage_80s_90s') score += 20;
    if (category === 'mall_nostalgia') score += 30; // K-mart nostalgia is premium!
    if (category === 'general_nostalgic') score += 15;
    
    // Filename keyword bonuses
    if (name.includes('nickelodeon') || name.includes('cartoon')) score += 20;
    if (name.includes('mall') || name.includes('kmart') || name.includes('store')) score += 25;
    if (name.includes('80s') || name.includes('90s')) score += 15;
    if (name.includes('commercial') || name.includes('ad')) score += 10;
    if (name.includes('retro') || name.includes('vintage') || name.includes('nostalgia')) score += 15;
    if (name.includes('neon') || name.includes('vhs') || name.includes('aesthetic')) score += 10;
    
    return Math.min(100, score);
  }

  // DIRECT OGG VIDEO DETECTION (Using your downloaded files!)
  async detectOggVideos() {
    console.log('üé¨ Loading OGG videos from your downloaded Archive.org collection...');
    console.log('üìÅ Expected structure: ./videos/[collection_name]/[video_files].ogg');
    
    // Define your downloaded video collections (MULTI-FORMAT SUPPORT!)
    const localVideoCollections = [
      // Collection 1: 90s Commercials (from https://archive.org/details/Collectionof90sCommercials)
      {
        folder: './videos/collection_90s_commercials/',
        category: '90s_commercials',
        description: 'Nickelodeon-aired 90s ads: toy promos, cereal spots, Happy Meals',
        files: [
          // MULTI-FORMAT SUPPORT: .ogg, .mp4, .webm, .avi, .mov, .mkv
          // Add your actual downloaded files here, e.g.:
          // 'nickelodeon_toy_ad_01.ogg',
          // 'cereal_commercial_90s.mp4',      // MP4 widely supported
          // 'happy_meal_promo.webm',          // WebM excellent for web
          // 'saturday_morning_ads.avi',       // AVI supported in most browsers
          // 'cartoon_break_compilation.mov',  // MOV/QuickTime supported
          // 'toy_commercial_mix.mkv'          // MKV supported in newer browsers
        ]
      },
      
      // Collection 2: Vintage 80s/90s Commercials
      {
        folder: './videos/vintage_commercials_80s_90s/',
        category: 'vintage_80s_90s', 
        description: 'CBS/ABC/FOX breakfast & cartoon break commercials',
        files: [
          // Add your files in any format, e.g.:
          // 'cbs_breakfast_ads.mp4',
          // 'abc_cartoon_commercials.webm',
          // 'fox_network_promos.ogg',
          // 'weekend_morning_compilation.avi'
        ]
      },
      
      // Collection 3: TV Commercials 60fps (High Quality!)
      {
        folder: './videos/tv_commercials_60fps/',
        category: 'high_framerate',
        description: 'High-frame-rate 80s-90s ad compilations',
        files: [
          // High-quality formats recommended for 60fps:
          // 'smooth_commercials_80s.mp4',     // MP4 excellent for 60fps
          // 'hd_upscaled_ads_90s.webm',       // WebM great compression for 60fps
          // 'vista_group_compilation.mkv'     // MKV supports high bitrates
        ]
      },
      
      // Collection 4: K-mart/Mall Culture
      {
        folder: './videos/kmart_pharmacy_70s_80s/',
        category: 'mall_nostalgia',
        description: 'In-store ad reels, mall culture vibes',
        files: [
          // Any format works - K-Lite will help with system playback:
          // 'kmart_pharmacy_spots.avi',
          // 'mall_store_ambiance.mp4',
          // 'retail_nostalgia_70s.mov'
        ]
      },
      
      // Collection 5: Mixed Compilation
      {
        folder: './videos/commercial_compilation_80s_2000s/',
        category: 'mixed_era',
        description: 'Curated mix: kids + adult ads, toys, food, tech',
        files: [
          // Archive.org often provides multiple formats:
          // 'eclectic_ad_mix.mp4',
          // 'generational_bridge_ads.webm',
          // 'diverse_commercial_compilation.ogg'
        ]
      },
      
      // Collection 6: NBC 80s VHS
      {
        folder: './videos/nbc_80s_vhs_60fps/',
        category: 'network_vhs',
        description: 'NBC network ads from VHS, grainy authenticity',
        files: [
          // VHS transfers often come as:
          // 'nbc_80s_promos.avi',            // Common for VHS transfers
          // 'vhs_quality_commercials.mp4',   // Re-encoded for web
          // 'network_nostalgia_compilation.mkv'
        ]
      }
    ];
    
    const detectedVideos = [];
    
    // Process each collection with multi-format support
    for (const collection of localVideoCollections) {
      for (const filename of collection.files) {
        const fileExtension = filename.split('.').pop().toLowerCase();
        const videoInfo = {
          id: filename.replace(/\.[^/.]+$/, ""), // Remove extension
          url: collection.folder + filename,
          localPath: collection.folder + filename,
          duration: 30, // Default duration - could be detected later
          format: fileExtension,
          category: collection.category,
          description: collection.description,
          isTherapeutic: this.isTherapeuticContent(filename, collection.category),
          isNostalgic: true, // All Archive.org content is nostalgic!
          vaporScore: this.calculateLocalVideoVaporScore(filename, collection.category),
          isLocal: true,
          // Browser compatibility info
          browserSupport: this.getBrowserSupport(fileExtension),
          webOptimized: this.isWebOptimized(fileExtension)
        };
        
        detectedVideos.push(videoInfo);
        const supportInfo = videoInfo.browserSupport.excellent ? '‚úÖ' : 
                           videoInfo.browserSupport.good ? '‚ö†Ô∏è' : '‚ùå';
        console.log(`üé¨ Registered ${fileExtension.toUpperCase()} video: ${filename} ${supportInfo} (Score: ${videoInfo.vaporScore})`);
      }
    }
    
    this.availableVideos = detectedVideos;
    console.log(`üé¨ Registered ${detectedVideos.length} videos from downloaded collections!`);
    
    if (detectedVideos.length > 0) {
      // Format compatibility report
      const formatStats = {};
      detectedVideos.forEach(video => {
        formatStats[video.format] = (formatStats[video.format] || 0) + 1;
      });
      
      console.log('üéØ FORMAT COMPATIBILITY REPORT:');
      Object.entries(formatStats).forEach(([format, count]) => {
        const support = this.getBrowserSupport(format);
        const icon = support.excellent ? '‚úÖ' : support.good ? '‚ö†Ô∏è' : support.limited ? 'üî∂' : '‚ùì';
        console.log(`  ${icon} ${format.toUpperCase()}: ${count} files - ${support.note}`);
      });
      
      console.log('üí° K-Lite Codec Pack helps with system playback, browser support varies by format');
      console.log('üåü Best web formats: MP4 (universal), WebM (modern), OGG (open source)');
    }
    
    if (detectedVideos.length === 0) {
      console.log('üí° No videos in local collections. To add your downloaded Archive.org videos:');
      console.log('üìÅ 1. Create collection folders: ./videos/collection_90s_commercials/, etc.');
      console.log('üé¨ 2. Copy your downloaded video files (ANY FORMAT) into appropriate folders');
      console.log('üìù 3. Edit the localVideoCollections array above with your actual filenames');
      console.log('üéØ 4. Supported formats: MP4, WebM, OGG, AVI, MOV, MKV, and more!');
      console.log('üö´ 5. This completely eliminates Archive.org CORS/400 errors!');
      console.log('‚ö° 6. Much faster loading since files are local!');
      console.log('üîß 7. K-Lite Codec Pack helps with system playback compatibility');
      
      // Create demo entry so system still works
      detectedVideos.push({
        id: 'demo_local',
        url: './videos/demo_nostalgic.mp4', // Changed to MP4 for better compatibility
        localPath: './videos/demo_nostalgic.mp4',
        duration: 30,
        format: 'mp4',
        category: 'demo',
        description: 'Demo local video file',
        isTherapeutic: false,
        isNostalgic: true,
        vaporScore: 70,
        isLocal: true,
        browserSupport: { excellent: true, note: 'Universal support' },
        webOptimized: true
      });
      
      this.availableVideos = detectedVideos;
    }
    
    return detectedVideos;
  }
  
  // Check if content has therapeutic value
  isTherapeuticContent(filename, category) {
    const name = filename.toLowerCase();
    return name.includes('ambient') || 
           name.includes('healing') || 
           name.includes('therapeutic') || 
           name.includes('calm') ||
           category === 'mall_nostalgia'; // Mall nostalgia is therapeutic!
  }
  
  // Browser format support detection (K-Lite helps system, but browser limits web)
  getBrowserSupport(format) {
    const supportMatrix = {
      // Excellent browser support (recommended)
      'mp4': { excellent: true, note: 'Universal support, best choice' },
      'webm': { excellent: true, note: 'Modern browsers, great compression' },
      
      // Good browser support
      'ogg': { good: true, note: 'Firefox/Chrome, open source' },
      'avi': { good: true, note: 'Most browsers, older format' },
      'mov': { good: true, note: 'Safari excellent, others vary' },
      
      // Limited support (may work with K-Lite system help)
      'mkv': { limited: true, note: 'Newer browsers only' },
      'flv': { limited: true, note: 'Legacy format, limited support' },
      'wmv': { limited: true, note: 'Windows-centric, varies' },
      
      // Unknown format
      'default': { unknown: true, note: 'Check browser console for support' }
    };
    
    return supportMatrix[format] || supportMatrix['default'];
  }
  
  // Check if format is web-optimized
  isWebOptimized(format) {
    const webOptimal = ['mp4', 'webm', 'ogg'];
    return webOptimal.includes(format);
  }
  
  // Enhanced video scoring with category support
  calculateLocalVideoVaporScore(filename, category) {
    let score = 60; // Base score for videos
    const name = filename.toLowerCase();
    
    // Category bonuses (same as image scoring for consistency)
    if (category === '90s_commercials') score += 25;
    if (category === 'vintage_80s_90s') score += 20;
    if (category === 'mall_nostalgia') score += 30; // K-mart nostalgia is premium!
    if (category === 'high_framerate') score += 15; // 60fps bonus
    if (category === 'mixed_era') score += 10;
    if (category === 'network_vhs') score += 20; // VHS aesthetic bonus
    
    // Filename keyword bonuses
    if (name.includes('nickelodeon') || name.includes('cartoon')) score += 20;
    if (name.includes('mall') || name.includes('kmart') || name.includes('store')) score += 25;
    if (name.includes('80s') || name.includes('90s')) score += 15;
    if (name.includes('commercial') || name.includes('ad')) score += 10;
    if (name.includes('retro') || name.includes('vintage') || name.includes('nostalgia')) score += 15;
    if (name.includes('vhs') || name.includes('aesthetic')) score += 10;
    if (name.includes('therapeutic') || name.includes('healing') || name.includes('ambient')) score += 25;
    if (name.includes('60fps') || name.includes('smooth') || name.includes('hd')) score += 10;
    
    return Math.min(100, score);
  }
  
  // Frame sequence detection (legacy support)
  detectVideoSequences() {
    // ENHANCED FOR YOUR UPSCALED WORKFLOW + DYNAMIC DETECTION (Code 2!)
    
    // Process known video list (no network requests = no CORS spam)
    for (const videoId of knownVideoList) {
      const videoInfo = {
        id: videoId,
        url: `${this.videoFolder}${videoId}.ogg`,
        duration: 30, // Default duration
        format: 'ogg',
        isTherapeutic: videoId.includes('healing') || videoId.includes('therapeutic') || videoId.includes('ambient'),
        isNostalgic: videoId.includes('vintage') || videoId.includes('retro') || videoId.includes('commercial'),
        vaporScore: this.calculateVideoVaporScore(videoId)
      };
      
      detectedVideos.push(videoInfo);
      console.log(`üìù Registered OGG video: ${videoId}.ogg`);
    }
    
    this.availableVideos = detectedVideos;
    console.log(`üé¨ Registered ${detectedVideos.length} OGG videos from manual list!`);
    
    if (detectedVideos.length === 0) {
      console.log('ÔøΩ No videos in manual list. To add your 200+ videos:');
      console.log('üìù Edit the knownVideoList array in detectOggVideos() method');
      console.log('üìÅ Expected folder structure: ./videos/[filename].ogg');
      console.log('üîß This prevents CORS detection spam in Firefox');
      
      // Fallback: Create some demo entries so the system still works
      detectedVideos.push({
        id: 'demo_therapeutic',
        url: `${this.videoFolder}demo_therapeutic.ogg`,
        duration: 30,
        format: 'ogg',
        isTherapeutic: true,
        isNostalgic: false,
        vaporScore: 85
      });
      
      this.availableVideos = detectedVideos;
    }
    
    return detectedVideos;
  }
  
  // Calculate vaporwave score for video based on filename
  calculateVideoVaporScore(filename) {
    let score = 60; // Base score for videos
    const name = filename.toLowerCase();
    
    // High-value therapeutic content
    if (name.includes('therapeutic') || name.includes('healing') || name.includes('ambient')) score += 25;
    if (name.includes('nostalgia') || name.includes('retro') || name.includes('vintage')) score += 20;
    if (name.includes('commercial') || name.includes('advertisement') || name.includes('tv_spot')) score += 15;
    if (name.includes('mall') || name.includes('kmart') || name.includes('saturday_morning')) score += 15;
    if (name.includes('90s') || name.includes('80s') || name.includes('family')) score += 10;
    
    // Grok 4 Archive.org collections get premium scores
    if (name.includes('collection_90s') || name.includes('vintage_commercials') || name.includes('nbc_80s')) score += 30;
    
    return Math.min(100, score);
  }
  
  // Frame sequence detection (legacy support)
  detectVideoSequences() {
    // ENHANCED FOR YOUR UPSCALED WORKFLOW + DYNAMIC DETECTION (Code 2!)
    this.availableSequences = [
      // Your actual upscaled sequences
      'yes', // The one from your screenshot!
      'retro_commercial_01',
      'synthwave_demo_02', 
      'vhs_graphics_03',
      'computer_animation_04',
      'ai_upscaled_demo_05',
      
      // GROK 4 TREASURE TROVE - Archive.org Video Collections!
      'collection_90s_commercials',        // Nickelodeon-aired ads, toy promos, cereal spots
      'vintage_commercials_80s_90s',       // CBS/ABC/FOX breakfast & cartoon breaks
      'tv_commercials_60fps_part16',       // High frame-rate compilations
      'kmart_pharmacy_70s_80s',            // Mall culture vibes, abandoned retail nostalgia
      'commercial_compilation_80s_2000s',   // Curated mix, eclectic sampled style
      'nbc_80s_vhs_60fps'                  // VHS authenticity with grainy aesthetic
      // Add your actual video IDs here
    ];
    
    // Configuration for upscaled content
    this.upscaledQuality = {
      'yes': { originalSize: '< 1MB', upscaledSize: '1.28MB', resolution: '2560x1440', duration: 28 },
      'deflicker_demo': { 
        originalSize: '8mm film', 
        upscaledSize: '16mm equivalent', 
        resolution: 'Flicker-free', 
        duration: 15,
        workflow: 'DaVinci + FFmpeg Nuclear Option',
        ghosting: '0%',
        commercial_equivalent: '$200+ Topaz alternative'
      },
      
      // GROK 4 ARCHIVE.ORG COLLECTIONS - Prime vaporwave fuel!
      'collection_90s_commercials': {
        archiveUrl: 'https://archive.org/details/Collectionof90sCommercials',
        description: 'Nickelodeon-aired 90s ads: toy promos, cereal spots, Happy Meals',
        aestheticScore: 95,
        vaporwaveElements: 'Bright colors, cheesy jingles, early CGI, ironic nostalgia',
        therapyValue: 'Mall-era comfort, childhood security memories',
        duration: 'Multiple clips',
        quality: '60fps ready for clean extraction'
      },
      'vintage_commercials_80s_90s': {
        archiveUrl: 'https://archive.org/details/Vintage_Commercials_Advertisements_80s',
        description: 'CBS/ABC/FOX breakfast & cartoon break commercials',
        aestheticScore: 98,
        vaporwaveElements: 'Neon graphics, fast-food pitches, consumer dream aesthetics',
        therapyValue: 'Saturday morning nostalgia, family TV time',
        duration: 'Hours of footage across multiple volumes',
        quality: 'Multiple format options'
      },
      'tv_commercials_60fps_part16': {
        archiveUrl: 'https://archive.org/details/TheVistaGroup-1980s1990s2000sTVCommercialsPart16',
        description: 'High-frame-rate 80s-90s ad compilations',
        aestheticScore: 90,
        vaporwaveElements: 'Smooth hypnotic flow, product demos, network bumps',
        therapyValue: 'Clean visual flow for meditation',
        duration: 'Assorted clips with early 2000s transitional aesthetics',
        quality: '60 FPS - PERFECT for frame extraction'
      },
      'kmart_pharmacy_70s_80s': {
        archiveUrl: 'https://archive.org/details/KmartPharmacySpots1970s',
        description: 'In-store ad reels, mall culture vibes',
        aestheticScore: 92,
        vaporwaveElements: 'Abandoned retail nostalgia, ambient store sounds',
        therapyValue: 'Simpler times when shopping felt safe & familiar',
        duration: 'Audio-visual reel segments',
        quality: 'Era-authentic with ambient soundscape potential'
      },
      'commercial_compilation_80s_2000s': {
        archiveUrl: 'https://archive.org/details/80s-2000s-commercial-compilation',
        description: 'Curated mix: kids + adult ads, toys, food, tech',
        aestheticScore: 88,
        vaporwaveElements: 'Eclectic sampled style, glitchy transitions',
        therapyValue: 'Generational bridge content',
        duration: 'Segmented compilation clips',
        quality: 'Variety pack for diverse therapeutic needs'
      },
      'nbc_80s_vhs_60fps': {
        archiveUrl: 'https://archive.org/details/TheVistaGroup-LVTVG023NBC1980s',
        description: 'NBC network ads from VHS, grainy authenticity',
        aestheticScore: 96,
        vaporwaveElements: 'VHS aesthetic, network promos, celebrity endorsements',
        therapyValue: 'Premium TV era nostalgia - when TV was appointment viewing',
        duration: 'Network-focused compilation',
        quality: '60 FPS from VHS - perfect grainy + smooth combo'
      }
    };
    
    // DYNAMIC SEQUENCE DETECTION (Your Code 2 integration!)
    this.fetchSequencesFromServer();
    
    console.log(`üé¨ Available video sequences: ${this.availableSequences.length}`);
    console.log('üîç Enhanced with AI upscaling support');
  }

  // STATIC SEQUENCE LIST (No CORS spam!)
  async fetchSequencesFromServer() {
    try {
      // SOLUTION: Use manual sequence list instead of auto-detection
      // This prevents CORS spam when running from local files
      
      const knownSequences = [
        // Add your actual frame sequences here manually
        // Example: 'yes', 'retro_commercial_01', 'synthwave_demo_02',
        
        // Uncomment and add your actual sequences to avoid CORS detection:
        // 'vhs_graphics_03', 'computer_animation_04', 'ai_upscaled_demo_05',
        // 'neon_cityscape', 'vintage_tech_demo', 'synthwave_car',
        
        // GROK 4 Archive.org frame sequences (when you extract them):
        // 'collection_90s_commercials', 'vintage_commercials_80s_90s',
        // 'tv_commercials_60fps_part16', 'kmart_pharmacy_70s_80s',
        // 'commercial_compilation_80s_2000s', 'nbc_80s_vhs_60fps'
      ];
      
      // Update available sequences with known ones (no network requests)
      this.availableSequences = [...new Set([...this.availableSequences, ...knownSequences])];
      console.log(`üìù Registered ${knownSequences.length} frame sequences from manual list`);
      
      if (knownSequences.length === 0) {
        console.log('üí° No frame sequences in manual list. To add your sequences:');
        console.log('üìù Edit the knownSequences array in fetchSequencesFromServer() method');
        console.log('üìÅ Expected structure: ./frames/[sequence_name]/frame_0001.png, etc.');
        console.log('ÔøΩ This prevents CORS detection spam in Firefox');
      }
      
    } catch (error) {
      console.warn('Sequence registration failed:', error);
      console.log('üìÅ Using static sequence list');
    }
  }

  // Enhanced sequence detection for production
  async fetchSequencesFromNodeServer() {
    // YOUR CODE 2: Perfect Node.js integration!
    // Skip server fetch when running from file:// protocol to avoid CORS
    if (window.location.protocol === 'file:') {
      console.log('üí° Skipping server sequence fetch (running from local file)');
      return this.fetchSequencesFromServer(); // Use manual list instead
    }
    
    try {
      const response = await fetch('/sequences');
      const serverSequences = await response.json();
      
      // Merge with existing sequences
      this.availableSequences = [...new Set([...this.availableSequences, ...serverSequences])];
      console.log(`üåê Server provided ${serverSequences.length} sequences:`, serverSequences);
      
      // Auto-detect quality metadata for server sequences
      for (const seqId of serverSequences) {
        if (!this.upscaledQuality[seqId]) {
          this.upscaledQuality[seqId] = await this.analyzeSequenceQuality(seqId);
        }
      }
      
    } catch (error) {
      console.warn('Server sequence fetch failed, using client detection:', error);
      return this.fetchSequencesFromServer(); // Fallback
    }
  }

  // Load a complete frame sequence from extracted video (CORS-safe)
  async loadFrameSequence(videoId, frameCount = 240) { // Default 10s @ 24fps
    if (this.frameSequences[videoId]) {
      console.log(`üéûÔ∏è Using cached sequence: ${videoId}`);
      return this.frameSequences[videoId];
    }

    console.log(`üé¨ Loading AI-upscaled sequence: ${videoId} (attempting ${frameCount} frames)`);
    console.log(`üí° Note: Frame loading may fail due to CORS restrictions in Firefox`);
    
    const sequence = [];
    let loadedFrames = 0;
    let consecutiveFailures = 0;
    const maxConsecutiveFailures = 5; // Stop after 5 consecutive failures
    
    // Try to load frame sequence, but with better error handling
    for (let i = 1; i <= frameCount && consecutiveFailures < maxConsecutiveFailures; i++) {
      try {
        const frameUrl = `./frames/${videoId}/frame_${i.toString().padStart(4, '0')}.png`;
        const texture = await createTextureFromURL(frameUrl);
        sequence.push({ 
          url: frameUrl, 
          texture, 
          frameNumber: i,
          isUpscaled: true // Mark as AI-enhanced
        });
        loadedFrames++;
        consecutiveFailures = 0; // Reset failure counter
        
        // Less verbose progress feedback
        if (i % 60 === 0) {
          console.log(`üìº Loaded ${i} frames for ${videoId}`);
        }
      } catch (error) {
        consecutiveFailures++;
        
        // Only warn on first few failures to avoid spam
        if (consecutiveFailures <= 3) {
          console.warn(`‚ö†Ô∏è Frame ${i} failed for ${videoId}. This is normal if frames don't exist.`);
        }
        
        // Stop early if we're getting too many failures
        if (consecutiveFailures >= maxConsecutiveFailures) {
          console.log(`üõë Stopping frame load for ${videoId} after ${maxConsecutiveFailures} consecutive failures`);
          break;
        }
      }
    }
    
    if (loadedFrames > 24) { // At least 1 second of content
      this.frameSequences[videoId] = sequence;
      const quality = this.upscaledQuality[videoId];
      console.log(`‚úÖ Loaded sequence: ${videoId} (${loadedFrames} frames)`);
      if (quality) {
        console.log(`üîç Quality: ${quality.originalSize} ‚Üí ${quality.upscaledSize} @ ${quality.resolution}`);
      }
      return sequence;
    } else {
      console.log(`üìù No frames loaded for ${videoId}. Add frames to ./frames/${videoId}/ folder.`);
      return null;
    }
  }

  selectWeightedRandom() {
    if (this.images.length === 0) return null;
    
    // Weight selection by vapor score
    const totalWeight = this.images.reduce((sum, img) => sum + img.vaporScore, 0);
    let random = Math.random() * totalWeight;
    
    for (const img of this.images) {
      random -= img.vaporScore;
      if (random <= 0) return img;
    }
    
    return this.images[0]; // Fallback
  }

  async preloadTextures() {
    const toPreload = Math.min(this.maxPreload, this.images.length);
    
    for (let i = 0; i < toPreload; i++) {
      try {
        const img = this.selectWeightedRandom();
        if (img) {
          const texture = await createTextureFromURL(img.url);
          this.preloadQueue.push({ texture, metadata: img });
          
          if (i === 0 && !this.currentTexture) {
            this.currentTexture = texture;
          }
        }
      } catch (error) {
        console.warn('Preload failed:', error);
      }
    }
    
    console.log(`üì¶ Preloaded ${this.preloadQueue.length} textures`);
  }

  async streamNext(beatIntensity = 0) {
    // PRIORITIZE YOUR 200+ OGG VIDEO COLLECTION!
    const shouldPlayOggVideo = Math.random() < this.videoSequenceChance && this.availableVideos.length > 0;
    
    if (shouldPlayOggVideo) {
      // Pick random OGG video from your collection
      const randomVideo = this.availableVideos[Math.floor(Math.random() * this.availableVideos.length)];
      console.log(`üé¨ Streaming OGG video: ${randomVideo.id} (Vapor Score: ${randomVideo.vaporScore})`);
      
      try {
        // Create video element and texture
        const video = document.createElement('video');
        video.crossOrigin = 'anonymous';
        video.loop = false;
        video.muted = false; // Keep audio for therapeutic effect
        video.playsInline = true;
        video.src = randomVideo.url;
        
        // Wait for video to be ready
        await new Promise((resolve, reject) => {
          video.oncanplaythrough = resolve;
          video.onerror = reject;
        });
        
        // Create WebGL texture from video
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        // Set up continuous texture updates
        this.currentVideo = video;
        this.currentTexture = texture;
        this.nextTexture = null;
        
        // Beat-responsive effects
        if (beatIntensity > 0.5) {
          video.playbackRate = 1.0 + beatIntensity * 0.3;
        }
        
        // Start playback
        video.play();
        
        console.log(`üìΩÔ∏è Playing OGG: ${randomVideo.id} (${randomVideo.duration || 'auto'}s)`);
        console.log(`üíô Therapy Value: ${randomVideo.isTherapeutic ? 'High' : randomVideo.isNostalgic ? 'Medium' : 'Standard'}`);
        
        return;
        
      } catch (error) {
        console.warn('OGG video playback failed, falling back:', error);
      }
    }
    
    // FALLBACK: Original image/frame logic
    const shouldPlayFrames = Math.random() < 0.5 && this.availableSequences.length > 0;
    
    if (shouldPlayFrames) {
      // Frame sequence logic (your original code)
      const videoId = this.availableSequences[Math.floor(Math.random() * this.availableSequences.length)];
      console.log(`üé¨ Streaming frame sequence: ${videoId}`);
      
      try {
        this.currentFrames = await this.loadFrameSequence(videoId, 240);
        if (this.currentFrames) {
          this.frameIndex = 0;
          this.nextTexture = null;
          this.currentFrameRate = this.baseFrameRate;
          this.lastFrameTime = performance.now();
          
          if (beatIntensity > 0.5) {
            this.frameSpeedMultiplier = 1.0 + beatIntensity * 1.5;
          }
          
          console.log(`üìΩÔ∏è Playing ${this.currentFrames.length} frames @ ${this.currentFrameRate}fps`);
          return;
        }
      } catch (error) {
        console.warn('Frame sequence failed, falling back to image:', error);
      }
    }
    
    // FINAL FALLBACK: Static images
    let nextItem;
    if (this.preloadQueue.length > 0) {
      nextItem = this.preloadQueue.shift();
      this.nextTexture = nextItem.texture;
    } else {
      try {
        const img = this.selectWeightedRandom();
        if (img) {
          this.nextTexture = await createTextureFromURL(img.url);
          nextItem = { texture: this.nextTexture, metadata: img };
        }
      } catch (error) {
        console.warn('Stream next failed:', error);
        return;
      }
    }
    
    // Trigger fade
    this.fadeProgress = 0;
    this.glitchIntensity = beatIntensity * 0.5;
    
    // Clear any active frame/video sequence
    this.currentFrames = null;
    this.currentVideo = null;
    
    // Maintain preload queue
    this.maintainPreloadQueue();
    
    console.log('üîÑ Streaming image:', nextItem?.metadata?.title || 'Unknown');
  }

  async maintainPreloadQueue() {
    while (this.preloadQueue.length < this.maxPreload) {
      try {
        const img = this.selectWeightedRandom();
        if (img) {
          const texture = await createTextureFromURL(img.url);
          this.preloadQueue.push({ texture, metadata: img });
        }
      } catch (error) {
        break; // Stop if we can't preload
      }
    }
  }

  updateFade(deltaTime, beatIntensity = 0) {
    // FRAME SEQUENCE PLAYBACK (Your enhancement!)
    if (this.currentFrames) {
      const now = performance.now();
      const frameInterval = 1000 / (this.currentFrameRate * this.frameSpeedMultiplier);
      
      if (now - this.lastFrameTime >= frameInterval) {
        this.frameIndex = (this.frameIndex + 1) % this.currentFrames.length;
        this.lastFrameTime = now;
        
        // Update current texture to the new frame
        this.currentTexture = this.currentFrames[this.frameIndex].texture;
        
        // Beat-responsive frame rate modulation
        if (beatIntensity > 0.4) {
          this.frameSpeedMultiplier = 1.0 + beatIntensity * 2.0; // Faster on beats
        } else {
          this.frameSpeedMultiplier *= 0.98; // Gradually return to normal
          this.frameSpeedMultiplier = Math.max(0.5, this.frameSpeedMultiplier);
        }
        
        // Check if sequence is complete
        if (this.frameIndex === this.currentFrames.length - 1) {
          console.log('üé¨ Video sequence complete, preparing transition...');
          // Mark for transition but don't immediately clear
          setTimeout(() => {
            this.currentFrames = null;
            this.frameIndex = 0;
            // Trigger next content after longer therapeutic pause
            this.streamNext(beatIntensity);
          }, 3000); // 3-second delay for therapeutic absorption (was 1000ms)
        }
      }
      
      // Reduce glitch over time (still applicable for video)
      this.glitchIntensity *= 0.95;
      return; // Skip normal fade logic when playing frames
    }
    
    // NORMAL TEXTURE CROSSFADE (Original logic)
    if (this.nextTexture) {
      // Dynamic fade speed based on beat
      const fadeSpeed = this.dreamSpeed + (beatIntensity * this.beatFadeMultiplier * deltaTime);
      this.fadeProgress += fadeSpeed;
      
      // Reduce glitch over time
      this.glitchIntensity *= 0.95;
      
      if (this.fadeProgress >= 1.0) {
        // Complete transition
        if (this.currentTexture) {
          gl.deleteTexture(this.currentTexture);
        }
        this.currentTexture = this.nextTexture;
        this.nextTexture = null;
        this.fadeProgress = 0;
        this.glitchIntensity = 0;
      }
    }
  }

  getCurrentTexture() {
    return this.currentTexture;
  }

  getNextTexture() {
    return this.nextTexture;
  }

  getFadeProgress() {
    return this.fadeProgress;
  }

  getGlitchIntensity() {
    return this.glitchIntensity;
  }
  
  // FRAME SEQUENCE STATUS METHODS
  isPlayingFrames() {
    return this.currentFrames !== null;
  }
  
  getCurrentFrameInfo() {
    if (!this.currentFrames) return null;
    return {
      frameIndex: this.frameIndex,
      totalFrames: this.currentFrames.length,
      progress: this.frameIndex / this.currentFrames.length,
      frameRate: this.currentFrameRate * this.frameSpeedMultiplier
    };
  }
  
  // Manual frame sequence control
  async playSpecificSequence(videoId, frameCount = 240) {
    console.log(`üéÆ Manual playback: ${videoId}`);
    this.currentFrames = await this.loadFrameSequence(videoId, frameCount);
    if (this.currentFrames) {
      this.frameIndex = 0;
      this.nextTexture = null;
      this.lastFrameTime = performance.now();
      this.frameSpeedMultiplier = 1.0;
    }
  }
}

// Create vaporwave color palette texture
function createVaporwaveColorRamp(width = 256) {
  const data = new Uint8Array(width * 4);
  
  for (let x = 0; x < width; x++) {
    const t = x / width;
    
    // Classic vaporwave gradient: purple -> pink -> cyan -> blue
    let r, g, b;
    if (t < 0.25) {
      // Purple to pink
      const localT = t * 4;
      r = Math.floor((0.5 + localT * 0.5) * 255);
      g = Math.floor((0.0 + localT * 0.3) * 255);
      b = Math.floor((0.8 - localT * 0.3) * 255);
    } else if (t < 0.5) {
      // Pink to cyan
      const localT = (t - 0.25) * 4;
      r = Math.floor((1.0 - localT * 1.0) * 255);
      g = Math.floor((0.3 + localT * 0.7) * 255);
      b = Math.floor((0.5 + localT * 0.5) * 255);
    } else if (t < 0.75) {
      // Cyan to blue
      const localT = (t - 0.5) * 4;
      r = Math.floor((0.0) * 255);
      g = Math.floor((1.0 - localT * 0.5) * 255);
      b = Math.floor((1.0) * 255);
    } else {
      // Blue to purple
      const localT = (t - 0.75) * 4;
      r = Math.floor((0.0 + localT * 0.5) * 255);
      g = Math.floor((0.5 - localT * 0.5) * 255);
      b = Math.floor((1.0 - localT * 0.2) * 255);
    }
    
    data[x * 4] = r;
    data[x * 4 + 1] = g;
    data[x * 4 + 2] = b;
    data[x * 4 + 3] = 255;
  }
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
  
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  
  console.log('üå∫ Created vaporwave color ramp');
  return texture;
}

// Initialize the enhanced vaporwave system with OGG video support
const vaporAtlas = new VaporwaveVideoAtlas();
const vaporColorRamp = createVaporwaveColorRamp();

// Vertex shader
const vsSource = isWebGL2 ? `#version 300 es
in vec2 a_position;
out vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}` : `
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

// Vaporwave fragment shader
const fsSource = isWebGL2 ? `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 fragColor;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_bass;
uniform float u_fadeProgress;
uniform float u_glitchIntensity;

uniform sampler2D u_currentTexture;
uniform sampler2D u_nextTexture;
uniform sampler2D u_vaporColors;

// VHS noise function
float vhsNoise(vec2 uv, float time) {
  return fract(sin(dot(uv + time, vec2(12.9898, 78.233))) * 43758.5453);
}

// Enhanced CRT scanlines with beat responsiveness
float scanlines(vec2 uv, float beatIntensity) {
  float scanlineFreq = 800.0 + beatIntensity * 200.0; // Dynamic frequency
  float scanlineAlpha = 0.1 + beatIntensity * 0.15; // Intensity varies with beat
  return sin(uv.y * scanlineFreq) * scanlineAlpha + (1.0 - scanlineAlpha);
}

// Your beat-responsive hue shift (Code 1 inspiration!)
vec3 beatHueShift(vec3 color, float beatIntensity) {
  if (beatIntensity > 0.5) {
    float hueShift = beatIntensity * 1.57; // ~90 degrees in radians
    float s = sin(hueShift);
    float c = cos(hueShift);
    
    // RGB to HSV hue rotation matrix
    mat3 hueRotation = mat3(
      0.299 + 0.701*c + 0.168*s, 0.587 - 0.587*c + 0.330*s, 0.114 - 0.114*c - 0.497*s,
      0.299 - 0.299*c - 0.328*s, 0.587 + 0.413*c + 0.035*s, 0.114 - 0.114*c + 0.292*s,
      0.299 - 0.300*c + 1.25*s, 0.587 - 0.588*c - 1.05*s, 0.114 + 0.886*c - 0.203*s
    );
    
    return hueRotation * color;
  }
  return color;
}

void main() {
  vec2 uv = v_uv;
  
  // VHS distortion
  float distort = sin(uv.y * 20.0 + u_time * 2.0) * u_glitchIntensity * 0.01;
  uv.x += distort;
  
  // Sample current texture
  vec3 currentColor = texture(u_currentTexture, uv).rgb;
  
  // Crossfade with next texture
  vec3 finalColor = currentColor;
  if (u_fadeProgress > 0.0) {
    vec3 nextColor = texture(u_nextTexture, uv).rgb;
    finalColor = mix(currentColor, nextColor, u_fadeProgress);
  }
  
  // Apply vaporwave color grading
  float colorIndex = (finalColor.r + finalColor.g + finalColor.b) / 3.0;
  colorIndex += sin(u_time * 0.5) * 0.1; // Slow color cycling
  vec3 vaporColor = texture(u_vaporColors, vec2(colorIndex, 0.5)).rgb;
  
  // Blend original with vaporwave palette
  finalColor = mix(finalColor, vaporColor, 0.4 + u_bass * 0.3);
  
  // YOUR BEAT-RESPONSIVE HUE SHIFT! (Code 1)
  finalColor = beatHueShift(finalColor, u_bass);
  
  // Enhanced CRT effects with beat response
  finalColor *= scanlines(v_uv, u_bass);
  
  // Beat-responsive sepia and contrast (Code 1 inspiration)
  if (u_bass > 0.5) {
    // Sepia effect
    float gray = dot(finalColor, vec3(0.299, 0.587, 0.114));
    vec3 sepia = vec3(gray * 1.2, gray * 1.0, gray * 0.8);
    finalColor = mix(finalColor, sepia, 0.3);
    
    // Dynamic contrast boost
    finalColor = pow(finalColor, vec3(1.0 / (1.0 + u_bass * 0.2)));
  }
  
  // VHS noise
  float noise = vhsNoise(v_uv, u_time) * 0.05;
  finalColor += vec3(noise);
  
  // Brightness and saturation boost
  finalColor *= 1.2 + u_bass * 0.5;
  
  fragColor = vec4(finalColor, 1.0);
}` : `
precision highp float;
varying vec2 v_uv;

uniform float u_time;
uniform vec2 u_resolution;
uniform float u_bass;
uniform float u_fadeProgress;
uniform float u_glitchIntensity;

uniform sampler2D u_currentTexture;
uniform sampler2D u_nextTexture;
uniform sampler2D u_vaporColors;

float vhsNoise(vec2 uv, float time) {
  return fract(sin(dot(uv + time, vec2(12.9898, 78.233))) * 43758.5453);
}

float scanlines(vec2 uv, float beatIntensity) {
  float scanlineFreq = 800.0 + beatIntensity * 200.0;
  float scanlineAlpha = 0.1 + beatIntensity * 0.15;
  return sin(uv.y * scanlineFreq) * scanlineAlpha + (1.0 - scanlineAlpha);
}

vec3 beatHueShift(vec3 color, float beatIntensity) {
  if (beatIntensity > 0.5) {
    float hueShift = beatIntensity * 1.57;
    float s = sin(hueShift);
    float c = cos(hueShift);
    
    mat3 hueRotation = mat3(
      0.299 + 0.701*c + 0.168*s, 0.587 - 0.587*c + 0.330*s, 0.114 - 0.114*c - 0.497*s,
      0.299 - 0.299*c - 0.328*s, 0.587 + 0.413*c + 0.035*s, 0.114 - 0.114*c + 0.292*s,
      0.299 - 0.300*c + 1.25*s, 0.587 - 0.588*c - 1.05*s, 0.114 + 0.886*c - 0.203*s
    );
    
    return hueRotation * color;
  }
  return color;
}

void main() {
  vec2 uv = v_uv;
  
  float distort = sin(uv.y * 20.0 + u_time * 2.0) * u_glitchIntensity * 0.01;
  uv.x += distort;
  
  vec3 currentColor = texture2D(u_currentTexture, uv).rgb;
  vec3 finalColor = currentColor;
  
  if (u_fadeProgress > 0.0) {
    vec3 nextColor = texture2D(u_nextTexture, uv).rgb;
    finalColor = mix(currentColor, nextColor, u_fadeProgress);
  }
  
  float colorIndex = (finalColor.r + finalColor.g + finalColor.b) / 3.0;
  colorIndex += sin(u_time * 0.5) * 0.1;
  vec3 vaporColor = texture2D(u_vaporColors, vec2(colorIndex, 0.5)).rgb;
  
  finalColor = mix(finalColor, vaporColor, 0.4 + u_bass * 0.3);
  finalColor = beatHueShift(finalColor, u_bass);
  finalColor *= scanlines(v_uv, u_bass);
  
  if (u_bass > 0.5) {
    float gray = dot(finalColor, vec3(0.299, 0.587, 0.114));
    vec3 sepia = vec3(gray * 1.2, gray * 1.0, gray * 0.8);
    finalColor = mix(finalColor, sepia, 0.3);
    finalColor = pow(finalColor, vec3(1.0 / (1.0 + u_bass * 0.2)));
  }
  
  float noise = vhsNoise(v_uv, u_time) * 0.05;
  finalColor += vec3(noise);
  finalColor *= 1.2 + u_bass * 0.5;
  
  gl_FragColor = vec4(finalColor, 1.0);
}`;

// Create shader program
function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

function createProgram(vsSource, fsSource) {
  const vs = createShader(gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
  
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram(vsSource, fsSource);
gl.useProgram(program);

// Setup geometry
const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1, 1, -1, -1, 1, 1, 1
]), gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

// Get uniform locations
const uniforms = {
  time: gl.getUniformLocation(program, 'u_time'),
  resolution: gl.getUniformLocation(program, 'u_resolution'),
  bass: gl.getUniformLocation(program, 'u_bass'),
  fadeProgress: gl.getUniformLocation(program, 'u_fadeProgress'),
  glitchIntensity: gl.getUniformLocation(program, 'u_glitchIntensity'),
  currentTexture: gl.getUniformLocation(program, 'u_currentTexture'),
  nextTexture: gl.getUniformLocation(program, 'u_nextTexture'),
  vaporColors: gl.getUniformLocation(program, 'u_vaporColors')
};

// Audio setup
let audioContext, analyser, dataArray;
let bass = 0;

// RETRO TIME CAPSULE PLAYLIST INTEGRATION - ORGANIC GROWTH STRATEGY
const PLAYLIST_CONFIGS = {
  therapeutic: {
    // Your main channel's therapeutic content (17+ years expertise)
    channelId: 'UC_YOUR_MAIN_CHANNEL_ID', // Replace with actual channel ID
    playlistId: 'PLYourTherapeuticPlaylist', // Replace with actual playlist ID
    name: 'Therapeutic Restoration Mix',
    description: 'Curated for tinnitus relief and family healing - No paid promotion, just authentic healing',
    growthStrategy: 'Organic word-of-mouth through healing community',
    mission: 'Legitimate audience building vs algorithm manipulation'
  },
  nostalgia: {
    // RetroTimeCapsuleTV content - AI-generated "Super Soap" style branding!
    channelId: 'UCRetroTimeCapsuleTV_ID', // Perfect available name in 2025!
    playlistId: 'PLYourNostalgiaPlaylist', // Replace with nostalgia playlist ID
    name: 'Nostalgia Time Capsule',
    description: '3min shorts for 50-60+ generation comfort - "When things made sense"',
    branding: 'AI-generated fictional products (Super Soap approach)',
    audience: 'Organic growth through genuine nostalgic connection',
    philosophy: 'Quality over quantity - sustainable vs paid promotion trap'
  }
};

// Load therapeutic playlist (nature sounds + ambient for your dad's tinnitus relief)
function loadTherapeuticPlaylist() {
  console.log('üåä Loading Therapeutic Playlist - Tinnitus Relief & Family Healing');
  console.log('üíô Dedicated to your dad\'s journey from borderline suicidal ‚Üí peaceful');
  console.log('üéµ Nature soundscapes + frequency modulation expertise');
  console.log('üå± ORGANIC GROWTH STRATEGY:');
  console.log('  ‚Ä¢ No paid promotion - authentic audience building only');
  console.log('  ‚Ä¢ Legitimate growth vs algorithm manipulation dependency');
  console.log('  ‚Ä¢ Word-of-mouth through healing community connection');
  console.log('  ‚Ä¢ Quality therapeutic content over inflated view counts');
  console.log('üíù YouTube Premium respect - no ad interruptions during healing');
  
  // In production, this would connect to YouTube Data API
  // For now, we'll set up the framework
  const audio = document.getElementById('player');
  
  // Example therapeutic audio sources (using local files to avoid CORS)
  const therapeuticSources = [
    // Your curated local audio files - no more CORS issues!
    // './audio/therapeutic/nature-sounds-therapeutic.ogg',
    // './audio/therapeutic/brainwave-generator-alpha.ogg', 
    // './audio/therapeutic/ambient-restoration-mix.ogg',
    // './audio/therapeutic/healing-soundscape.ogg',
    // './audio/therapeutic/tinnitus-relief-mix.ogg', // For your dad!
    
    // Local Archive.org downloads (converted to OGG for web performance)
    // './audio/archive_downloads/commercials-ambient-mix.ogg',
    // './audio/archive_downloads/saturday-morning-therapy.ogg',
    // './audio/archive_downloads/mall-ambiance-healing.ogg'
  ];
  
  // Load first track and prepare playlist rotation
  if (therapeuticSources.length > 0) {
    audio.src = therapeuticSources[0];
    console.log('üéß Loaded therapeutic track for healing session');
  } else {
    console.log('üí° No therapeutic audio sources configured. Add local audio files to avoid CORS issues.');
    console.log('üìÅ Recommended: Place audio files in ./audio/ folder and update therapeuticSources array');
  }
}

// Load nostalgia playlist (your RetroTimeCapsuleTV content)
function loadNostalgiaPlaylist() {
  console.log('üí´ Loading Nostalgia Time Capsule - RetroTimeCapsuleTV Content');
  console.log('‚è∞ 3min max duration for 50-60+ attention retention');
  console.log('üîÑ "When things made sense" - bridge to simpler times');
  console.log('üéØ PERFECT BRANDING STRATEGY:');
  console.log('  ‚Ä¢ "RetroTimeCapsuleTV" - miraculous availability in 2025!');
  console.log('  ‚Ä¢ AI-generated fictional products (Super Soap approach)');
  console.log('  ‚Ä¢ Copyright-safe nostalgic content creation');
  console.log('  ‚Ä¢ Family around TV aesthetic without brand complications');
  console.log('üìà SUSTAINABLE GROWTH:');
  console.log('  ‚Ä¢ Organic subscriber growth - steady, authentic audience');
  console.log('  ‚Ä¢ No paid promotion trap - legitimate community building');
  console.log('  ‚Ä¢ YouTube backbone respect - original creator philosophy');
  
  const audio = document.getElementById('player');
  
  // Example nostalgia sources (using local files from your downloads)
  const nostalgiaSources = [
    // Your restored commercial compilations - local OGG files for optimal performance
    // './audio/nostalgia/retro-commercial-mix-80s.ogg',
    // './audio/nostalgia/nostalgic-tv-themes.ogg',
    // './audio/nostalgia/family-memories-soundtrack.ogg',
    // './audio/nostalgia/saturday-morning-nostalgia.ogg',
    
    // Local Archive.org downloads (no more CORS/400 errors!)
    // './audio/archive_downloads/vista-commercial-audio.ogg',
    // './audio/archive_downloads/nbc-nostalgia-mix.ogg', 
    // './audio/archive_downloads/eclectic-bridge-audio.ogg',
    // './audio/archive_downloads/mall-culture-ambiance.ogg'
  ];
  
  if (nostalgiaSources.length > 0) {
    audio.src = nostalgiaSources[0];
    console.log('üì∫ Loaded nostalgia mix for generational bridge');
  } else {
    console.log('üí° No nostalgia audio sources configured. Add local audio files to avoid CORS issues.');
    console.log('ÔøΩ Recommended: Place audio files in ./audio/ folder and update nostalgiaSources array');
  }
}

// Enhanced audio initialization with playlist support
async function initAudio() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const audio = document.getElementById('player');
    
    // OGG format support detection and optimization
    const oggSupport = audio.canPlayType('audio/ogg; codecs="vorbis"');
    const mp3Support = audio.canPlayType('audio/mpeg');
    
    console.log('üéµ Audio Format Support:');
    console.log(`  OGG Vorbis: ${oggSupport || 'Not supported'}`);
    console.log(`  MP3: ${mp3Support || 'Not supported'}`);
    
    if (oggSupport === 'probably' || oggSupport === 'maybe') {
      console.log('‚úÖ OGG Vorbis supported - optimal for Archive.org streaming!');
      console.log('üåê Web-optimized audio pipeline ready for therapeutic content');
    }
    
    // Set up default therapeutic mode (for your dad's tinnitus relief)
    loadTherapeuticPlaylist();
    
    const source = audioContext.createMediaElementSource(audio);
    
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.8;
    
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    console.log('üéµ Audio system initialized with OGG-optimized therapeutic playlist support');
    console.log('üíù Ready for healing through nostalgic soundscapes via Archive.org');
  } catch (error) {
    console.warn('Audio init failed:', error);
  }
}

function updateAudioData() {
  if (!analyser) return 0;
  
  analyser.getByteFrequencyData(dataArray);
  
  // Focus on bass frequencies for beat detection
  let bassSum = 0;
  for (let i = 0; i < 30; i++) bassSum += dataArray[i];
  bass = bassSum / (30 * 255);
  
  return bass;
}

// Create default texture for when no archive images are loaded
function createDefaultTexture() {
  const size = 256;
  const data = new Uint8Array(size * size * 4);
  
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const i = (y * size + x) * 4;
      const value = (Math.sin(x * 0.1) + Math.sin(y * 0.1)) * 0.5 + 0.5;
      data[i] = Math.floor(value * 100);     // Dark purple
      data[i + 1] = Math.floor(value * 50);  // 
      data[i + 2] = Math.floor(value * 150); // 
      data[i + 3] = 255;
    }
  }
  
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
  
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  
  return texture;
}

const defaultTexture = createDefaultTexture();
let lastTime = 0;
let lastBeatTime = 0;

// Render loop
function render(time) {
  time *= 0.001;
  const deltaTime = time - lastTime;
  lastTime = time;
  
  const currentBass = updateAudioData();
  
  // Beat detection with debouncing
  let beatIntensity = 0;
  if (currentBass > 0.3 && time - lastBeatTime > 0.5) {
    beatIntensity = currentBass;
    lastBeatTime = time;
    
    // Trigger new image on strong beats
    if (beatIntensity > 0.6) {
      vaporAtlas.streamNext(beatIntensity);
    }
  }
  
  // Update fade progress and handle video textures
  vaporAtlas.updateFade(deltaTime, beatIntensity);
  
  // UPDATE VIDEO TEXTURE if playing OGG video
  if (vaporAtlas.currentVideo && !vaporAtlas.currentVideo.paused && !vaporAtlas.currentVideo.ended) {
    gl.bindTexture(gl.TEXTURE_2D, vaporAtlas.currentTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, vaporAtlas.currentVideo);
  } else if (vaporAtlas.currentVideo && vaporAtlas.currentVideo.ended) {
    // Video finished - trigger next content
    console.log('üé¨ OGG video completed, transitioning...');
    vaporAtlas.currentVideo = null;
    vaporAtlas.streamNext(beatIntensity);
  }
  
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  // Bind textures
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, vaporAtlas.getCurrentTexture() || defaultTexture);
  gl.uniform1i(uniforms.currentTexture, 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, vaporAtlas.getNextTexture() || defaultTexture);
  gl.uniform1i(uniforms.nextTexture, 1);
  
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, vaporColorRamp);
  gl.uniform1i(uniforms.vaporColors, 2);
  
  // Set uniforms
  gl.uniform1f(uniforms.time, time);
  gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
  gl.uniform1f(uniforms.bass, bass);
  gl.uniform1f(uniforms.fadeProgress, vaporAtlas.getFadeProgress());
  gl.uniform1f(uniforms.glitchIntensity, vaporAtlas.getGlitchIntensity());
  
  // Draw
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  
  // UPDATE STATUS DISPLAY
  updateStatusDisplay();
  
  requestAnimationFrame(render);
}

// Status display update function (Enhanced with your Code 3!)
let statusDisplayTimeout = null;
let isWindowResizing = false;
let lastResizeTime = 0;

// Track window resize to prevent flickering during resize operations
window.addEventListener('resize', () => {
  isWindowResizing = true;
  lastResizeTime = performance.now();
  clearTimeout(statusDisplayTimeout);
  statusDisplayTimeout = setTimeout(() => {
    isWindowResizing = false;
  }, 500); // 500ms cooldown after resize
});

function updateStatusDisplay() {
  const statusDiv = document.getElementById('statusDisplay');
  const frameInfo = document.getElementById('frameInfo');
  const progressFill = document.getElementById('progressFill');
  
  const frameData = vaporAtlas.getCurrentFrameInfo();
  
  // Calculate FPS and performance metrics (Your Code 3!)
  const currentTime = performance.now();
  const deltaTime = (currentTime - (window.lastFrameTime || currentTime)) / 1000;
  window.lastFrameTime = currentTime;
  const fps = deltaTime > 0 ? Math.round(1 / deltaTime) : 60;
  
  // Anti-flicker logic: Don't show performance warnings during window operations
  const recentlyResized = (currentTime - lastResizeTime) < 1000; // 1 second grace period
  const shouldShowPerformanceWarning = !isWindowResizing && !recentlyResized && fps < 45; // Lower threshold
  
  if (frameData) {
    // Show frame sequence info with enhanced metrics (Code 3 inspiration!)
    statusDiv.style.display = 'block';
    
    const progress = frameData.progress * 100;
    const beatIntensity = bass || 0;
    
    // Your enhanced progress display
    frameInfo.innerHTML = `
      üé¨ Frame ${frameData.frameIndex + 1}/${frameData.totalFrames} @ ${frameData.frameRate.toFixed(1)}fps<br>
      <span style="font-size:12px; opacity:0.8;">
        FPS: ${fps} | Beat: ${beatIntensity.toFixed(2)} | Progress: ${progress.toFixed(1)}%
      </span>
    `;
    
    // Enhanced progress bar with vapor aesthetic (Code 3 style!)
    progressFill.style.width = `${progress}%`;
    
    // Beat-responsive progress bar color
    if (beatIntensity > 0.5) {
      progressFill.style.background = `linear-gradient(90deg, #ff00ff, #00ffff, #ff0080)`;
      progressFill.style.boxShadow = `0 0 ${beatIntensity * 10}px #ff00ff`;
    } else {
      progressFill.style.background = `linear-gradient(90deg, #ff00ff, #00ffff)`;
      progressFill.style.boxShadow = `none`;
    }
    
  } else if (vaporAtlas.getFadeProgress() > 0) {
    // Show image transition with performance data
    statusDiv.style.display = 'block';
    const fadeProgress = vaporAtlas.getFadeProgress() * 100;
    const beatIntensity = bass || 0;
    
    frameInfo.innerHTML = `
      üñºÔ∏è Image Transition (${fadeProgress.toFixed(0)}%)<br>
      <span style="font-size:12px; opacity:0.8;">
        FPS: ${fps} | Beat: ${beatIntensity.toFixed(2)} | Fade: ${fadeProgress.toFixed(1)}%
      </span>
    `;
    
    progressFill.style.width = `${fadeProgress}%`;
    progressFill.style.background = `linear-gradient(90deg, #00ffff, #ff00ff)`;
    
  } else {
    // ANTI-FLICKER LOGIC: Only show when genuinely interesting, not during window operations
    if (shouldShowPerformanceWarning || bass > 0.2) { // Higher beat threshold, lower FPS threshold
      statusDiv.style.display = 'block';
      frameInfo.innerHTML = `
        üì∑ Static Image<br>
        <span style="font-size:12px; opacity:0.8;">
          FPS: ${fps} | Beat: ${(bass || 0).toFixed(2)} | Mode: Archive.org
        </span>
      `;
      progressFill.style.width = '0%';
    } else {
      statusDiv.style.display = 'none';
    }
  }
  
  // Performance warning (your style!) - but not during resize operations
  if (!recentlyResized) {
    if (fps < 30) {
      frameInfo.style.color = '#ff4444';
      frameInfo.style.textShadow = '0 0 10px #ff4444';
    } else if (fps < 50) {
      frameInfo.style.color = '#ffff44';
      frameInfo.style.textShadow = '0 0 10px #ffff44';
    } else {
      frameInfo.style.color = '#ff00ff';
      frameInfo.style.textShadow = '0 0 10px #ff00ff';
    }
  }
}

// Initialize everything
async function main() {
  console.log('üå¥ Initializing Vaporwave Archive Visualizer...');
  console.log('ü§ñ AI-Human Collaboration: GitHub Copilot + 17+ Years Restoration Expertise');
  console.log('üíù Dedicated to therapeutic healing through technology');
  
  await initAudio();
  
  // Initialize with Archive.org content
  const initialized = await vaporAtlas.init('internetarchivebooks', {
    yearRange: { start: 1980, end: 1995 },
    subject: 'computer OR technology OR retro OR digital'
  });
  
  if (!initialized) {
    console.warn('‚ö†Ô∏è Failed to load archive content, using default textures');
  }
  
  render(0);
  console.log('üöÄ Vaporwave visualizer running!');
}

// Audio controls
document.getElementById('player').addEventListener('play', () => {
  if (audioContext?.state === 'suspended') {
    audioContext.resume();
  }
});

// Keyboard controls
document.addEventListener('keydown', (event) => {
  if (event.key === ' ') {
    event.preventDefault();
    vaporAtlas.streamNext(1.0); // Manual trigger
  }
  
  // ENHANCED CONTROLS FOR FRAME SEQUENCES
  if (event.key === 'v' || event.key === 'V') {
    // Force video sequence
    if (vaporAtlas.availableSequences.length > 0) {
      const randomVideo = vaporAtlas.availableSequences[Math.floor(Math.random() * vaporAtlas.availableSequences.length)];
      vaporAtlas.playSpecificSequence(randomVideo, 240);
      console.log('üé¨ Manual video trigger:', randomVideo);
    }
  }
  
  // SPECIAL KEY FOR YOUR AI-UPSCALED DEMO!
  if (event.key === 'y' || event.key === 'Y') {
    // Play your incredible "yes" sequence
    vaporAtlas.playSpecificSequence('yes', 672); // 28 seconds @ 24fps
    console.log('üîç Playing AI-upscaled demo: "yes" (1.28MB @ 2560x1440)');
  }
  
  // GROK 4 ARCHIVE.ORG COLLECTIONS! (The treasure trove!)
  if (event.key === 'g' || event.key === 'G') {
    // Cycle through Grok 4's Archive.org goldmine
    const grokCollections = [
      'collection_90s_commercials',        // Nickelodeon magic
      'vintage_commercials_80s_90s',       // Saturday morning security
      'tv_commercials_60fps_part16',       // Smooth therapeutic flow
      'nbc_80s_vhs_60fps'                  // Premium VHS authenticity
    ];
    
    const randomGrokCollection = grokCollections[Math.floor(Math.random() * grokCollections.length)];
    vaporAtlas.playSpecificSequence(randomGrokCollection, 300); // 12.5s clips
    
    const quality = vaporAtlas.upscaledQuality[randomGrokCollection];
    console.log('üèÜ GROK 4 DISCOVERY:', randomGrokCollection);
    console.log('üì∫ Archive.org URL:', quality?.archiveUrl);
    console.log('‚ú® Vaporwave Score:', quality?.aestheticScore + '/100');
    console.log('üíô Therapy Value:', quality?.therapyValue);
    console.log('üé® Aesthetic Elements:', quality?.vaporwaveElements);
  }
  
  // MALL NOSTALGIA MODE (Kmart & retail therapy)
  if (event.key === 'm' || event.key === 'M') {
    vaporAtlas.playSpecificSequence('kmart_pharmacy_70s_80s', 240);
    console.log('üè™ MALL NOSTALGIA MODE - Abandoned Retail Therapy');
    console.log('üõí Kmart pharmacy spots: Mall culture vibes + ambient store sounds');
    console.log('üï∞Ô∏è When shopping felt safe, familiar, and therapeutic');
    console.log('üíù Perfect for your dad\'s "simpler times" healing journey');
  }
  
  // TOPAZ QUALITY DEMO (Your deflicker mastery!)
  if (event.key === 't' || event.key === 'T') {
    // Showcase your superior deflicker + upscale workflow
    if (vaporAtlas.availableSequences.includes('deflicker_demo')) {
      vaporAtlas.playSpecificSequence('deflicker_demo', 360); // 15s demo
      console.log('üéûÔ∏è Deflicker Demo: 8mm‚Üí16mm restoration (Nuclear Option)');
      console.log('üìä DaVinci + FFmpeg deflicker=mode=am:size=15 ‚Üí 0% ghosting');
    } else {
      console.log('üí° T-Key: Topaz-beating deflicker workflow ready for deployment');
      console.log('üî¨ Stage 1: DaVinci Motion/None ‚Üí Stage 2: Fast ‚Üí Stage 3: FFmpeg am:size=15');
    }
  }
  
  if (event.key === 'i' || event.key === 'I') {
    // Force image mode
    vaporAtlas.currentFrames = null;
    vaporAtlas.streamNext(0.8);
    console.log('üñºÔ∏è Manual image trigger');
  }
  
  if (event.key === 'f' || event.key === 'F') {
    // Show frame info
    const frameInfo = vaporAtlas.getCurrentFrameInfo();
    if (frameInfo) {
      console.log(`üìΩÔ∏è Frame ${frameInfo.frameIndex + 1}/${frameInfo.totalFrames} (${(frameInfo.progress * 100).toFixed(1)}%) @ ${frameInfo.frameRate.toFixed(1)}fps`);
      const quality = vaporAtlas.upscaledQuality[vaporAtlas.currentVideoId];
      if (quality) {
        console.log(`üîç AI-Enhanced: ${quality.originalSize} ‚Üí ${quality.upscaledSize} @ ${quality.resolution}`);
      }
    } else {
      console.log('üì∑ Currently showing static image');
    }
  }
  
  if (event.key === 'c' || event.key === 'C') {
    // Toggle video sequence chance
    vaporAtlas.videoSequenceChance = vaporAtlas.videoSequenceChance === 0.3 ? 0.8 : 0.3;
    console.log(`üé≤ Video chance: ${(vaporAtlas.videoSequenceChance * 100).toFixed(0)}%`);
  }
  
  if (event.key === 'q' || event.key === 'Q') {
    // Show quality info for current sequence
    const sequences = vaporAtlas.upscaledQuality;
    console.log('üìä AI-Upscaled Sequences Available:');
    Object.entries(sequences).forEach(([id, quality]) => {
      console.log(`  ${id}: ${quality.originalSize} ‚Üí ${quality.upscaledSize} (${quality.compressionRatio || 'N/A'})`);
    });
  }
  
  // 7H 32M TIMELINE TRIBUTE (Your epic restoration masterpiece!)
  if (event.key === 'h' || event.key === 'H') {
    console.log('üéûÔ∏è TRIBUTE TO 7H 32M RESTORATION MASTERPIECE');
    console.log('üìà Timeline Architecture:');
    console.log('  ‚Ä¢ Source: Hundreds of period commercials (early era ‚Üí 90s)');
    console.log('  ‚Ä¢ Method: Frame-by-frame curation + DaVinci Object Remover');
    console.log('  ‚Ä¢ Export: H.265 @ original resolution (YouTube transcoding irrelevant)');
    console.log('  ‚Ä¢ Hardware: Overclocked 5800X + DDR4 (pre-beast mode)');
    console.log('üìΩÔ∏è Multi-Generation Source Chain:');
    console.log('  Family Footage ‚Üí VHS Camcorder ‚Üí VHS Deck ‚Üí DVD ‚Üí Professional Restoration');
    console.log('üîç Resolution Integrity: MAINTAINED through entire chain');
    console.log('‚ö° Professional Approach: Manual watermark removal vs automated tools');
    console.log('üèÜ 17+ Years Expertise: Archive preservation since 2008');
    
    // Special timeline mode for marathon content
    vaporAtlas.videoSequenceChance = 0.9; // 90% video for timeline tribute
    vaporAtlas.frameSpeedMultiplier = 0.8; // Slower, more contemplative pace
    console.log('üé¨ Switched to Timeline Mode: 90% video sequences @ contemplative pace');
  }
  
  // RETRO TIME CAPSULE MODE (Therapeutic nostalgia for your dad & family)
  if (event.key === 'r' || event.key === 'R') {
    console.log('üíô RETRO TIME CAPSULE MODE - Healing Through Nostalgia');
    console.log('üéµ Therapeutic Purpose:');
    console.log('  ‚Ä¢ Target: 50-60+ generation seeking "when things made sense"');
    console.log('  ‚Ä¢ Duration: 3min max shorts for attention retention');
    console.log('  ‚Ä¢ Healing: Tinnitus relief through nature soundscapes integration');
    console.log('  ‚Ä¢ Family: Bridge between generations via familiar visuals');
    console.log('üåä Frequency Modulation Expertise:');
    console.log('  ‚Ä¢ Brainwave generators research for dad\'s tinnitus relief');
    console.log('  ‚Ä¢ Nature sounds via MP3 players (borderline suicidal ‚Üí healing)');
    console.log('  ‚Ä¢ 17+ years family tech support (fixing computers/phones/TVs)');
    console.log('üí´ Cultural Preservation Mission:');
    console.log('  ‚Ä¢ Saving FEELING of simpler times, not just content');
    console.log('  ‚Ä¢ Making chaos-weary generation feel good about themselves');
    console.log('  ‚Ä¢ Giving back piece of their identity from manageable world');
    
    // Therapeutic mode: Slower, warmer, more meditative
    vaporAtlas.videoSequenceChance = 0.7; // Balanced video/image mix
    vaporAtlas.frameSpeedMultiplier = 0.6; // Very slow, meditative pace
    vaporAtlas.dreamSpeed = 0.002; // Extra slow fade for contemplation
    console.log('üßò Switched to Therapeutic Mode: Slow, meditative, healing pace');
    console.log('üíù Dedicated to your dad and family who need this bridge to simpler times');
  }
});

document.addEventListener('DOMContentLoaded', main);

  </script>
</body>
</html>
